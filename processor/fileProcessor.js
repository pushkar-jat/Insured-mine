const { parentPort, workerData } = require('worker_threads');
const fs = require('fs');
const path = require('path');
const csvParser = require('csv-parser');
const readXlsxFile = require('read-excel-file/node');
const mongoose = require('mongoose'); 

// Import the models
const { Agent, User, Account, LOB, Carrier, Policy } = require('../Model/model'); // Adjust the path as needed

// Helper function to parse dates
const parseDate = (dateString) => {
    return dateString ? new Date(dateString) : null;
};

// Helper function to convert strings to boolean
const parseBoolean = (value) => {
    return value?.toLowerCase() === 'true';
};

// Insert the data into MongoDB
const insertDataToDB = async (data) => {
    // Destructure your data here
    

    // Insert into MongoDB
    try {

        const {
            agent,
            userType,
            policy_mode,
            producer,
            policy_number,
            premium_amount_written,
            premium_amount,
            policy_type,
            company_name,
            category_name,
            policy_start_date,
            policy_end_date,
            csr,
            account_name,
            email,
            gender,
            firstname,
            city,
            account_type,
            phone,
            address,
            state,
            zip,
            dob,
            primary,
            ApplicantID,
            agency_id,
            hasActiveClientPolicy
        } = data;
    
        // Process and convert data to match the model fields
        // Here, we make some assumptions about data types and parsing needs
        const processedData = {
            agent_name: agent,
            agency_id: agency_id,
            isActive: userType === 'Active Client',
            user: {
                user_id: ApplicantID, // Assuming ApplicantID should be used as the user_id
                first_name: firstname,
                email: email,
                gender: gender,
                dob: parseDate(dob),
                address: address,
                city: city,
                state: state,
                zip: zip,
                phone_number: phone,
                primary: parseBoolean(primary),
                hasActiveClientPolicy: parseBoolean(hasActiveClientPolicy)
            },
            account: {
                account_name: account_name,
                account_type: account_type
                // user_id will be set after saving the user
            },
            lob: {
                category_name: category_name
                // category_id will be generated by MongoDB
            },
            carrier: {
                company_name: company_name
            },
            policy: {
                policy_number: policy_number,
                premium_amount_written: parseFloat(premium_amount_written || '0'),
                premium_amount: parseFloat(premium_amount || '0'),
                policy_type: policy_type,
                policy_start_date: parseDate(policy_start_date),
                policy_end_date: parseDate(policy_end_date),
                csr: csr,
                producer: producer,
                policy_mode: parseInt(policy_mode, 10)
                // user_id, carrier_id, and category_id will be set later
            }
        };
        const agentDoc = await Agent.findOneAndUpdate(
            { agent_name: processedData.agent_name },
            { $set: processedData },
            { new: true, upsert: true }
        );

        const userDoc = await User.findOneAndUpdate(
            { user_id: processedData.user.user_id },
            { $set: processedData.user },
            { new: true, upsert: true }
        );

        processedData.account.user_id = userDoc._id;
        const accountDoc = await Account.findOneAndUpdate(
            { account_name: processedData.account.account_name },
            { $set: processedData.account },
            { new: true, upsert: true }
        );

        const lobDoc = await LOB.findOneAndUpdate(
            { category_name: processedData.lob.category_name },
            { $set: processedData.lob },
            { new: true, upsert: true }
        );

        const carrierDoc = await Carrier.findOneAndUpdate(
            { company_name: processedData.carrier.company_name },
            { $set: processedData.carrier },
            { new: true, upsert: true }
        );

        processedData.policy.user_id = userDoc._id;
        processedData.policy.carrier_id = carrierDoc._id;
        processedData.policy.category_id = lobDoc._id;
        const policyDoc = await Policy.create(processedData.policy);

        parentPort.postMessage('Data inserted into DB successfully');
    } catch (error) {
        parentPort.postMessage(`Error inserting data into DB: ${error.message}`);
    }
};

 

// Function to process CSV file
const processCSV = async (filePath) => {
    const results = [];
    fs.createReadStream(filePath)
        .pipe(csvParser())
        .on('data', (row) => results.push(row))
        .on('end', async () => {
            try {
                for (let row of results) {
                    await insertDataToDB(row); // Process each row at a time
                }
                parentPort.postMessage('CSV file processed and data inserted into DB');
            } catch (error) {
                parentPort.postMessage(`Error processing CSV data: ${error.message}`);
            }
        })
        .on('error', (error) => {
            parentPort.postMessage(`Error processing CSV file: ${error.message}`);
        });
};

// Function to process XLSX file
const processXLSX = async (filePath) => {
    try {
        const data = await readXlsxFile(filePath);
        if (data.length > 1) {
            const headers = data[0]; // First row as headers
            const rows = data.slice(1); // All other rows as data

            for (let row of rows) {
                let rowData = {};
                headers.forEach((header, index) => {
                    rowData[header] = row[index];
                });
                await insertDataToDB(rowData); // Process each row at a time
            }
            parentPort.postMessage('XLSX file processed and data inserted into DB');
        } else {
            parentPort.postMessage('XLSX file does not contain enough data');
        }
    } catch (error) {
        parentPort.postMessage(`Error processing XLSX file: ${error.message}`);
    }
};


// Determine file type and process accordingly
const fileExtension = path.extname(workerData.originalname).toLowerCase();
if (fileExtension === '.csv') {
    processCSV(workerData.path);
} else if (fileExtension === '.xlsx') {
    processXLSX(workerData.path);
} else {
    parentPort.postMessage('Unsupported file type');
}

